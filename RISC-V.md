# หลักการทำงานของ Software EmulsiV
![microcontroller](https://cdn.xingosoftware.com/elektor/images/fetch/dpr_1,w_720/https%3A%2F%2Fwww.elektormagazine.com%2Fassets%2Fupload%2Fimages%2F42%2F20210405185330_210223-002-94-ORIGINAL-ELK026---ESEO-RISC-V-web-based-simulator.png)

#### ภาพแสดงส่วนประกอบใน microcontroller ประกอบไปด้วย 2 ส่วนหลักๆ คือ
1. ด้านบน เหนือแถบขึ้นมา
2. ด้านล่าง ใต้แถบลงมา

**ด้านบน ประกอบไปด้วย**
* **Memory**
* **วงจรคำนวณ ที่ CPU จะจัดการเอง ประกอบด้วย**
  - Bus
  - Program counter
  - Instruction reg.
  - ALU
  - Comparator
  - General-purpose regs
  
**ด้านล่าง จะเรียกทั้งแถบว่า I/O (Input/Output) ประกอบไปด้วย**
  * Text I/O คือ Output ที่เป็น Text
  * General-purpose I/O ประกอบด้วย 4 แถว แถวละ 8 ตัว รวมทั้งหมด 32 ช่อง
  * Bitmap output
  
### การจัดขนาดของข้อมูลของคอมพิวเตอร์ประเภท Microcontroller(RISC-V) จะมีหลักๆ 3 คำ คือ
1. *Word* คือ ทั้งแถบ หรือ 4 bit เช่น
- ที่ตำแหน่ง Address1 1 word คือ 02 00 00 93
- ที่ตำแหน่ง Address14 1 word คือ 00 10 80 93
2. *Half Word* คือ ครึ่งของ word เช่น
- ที่ตำแหน่ง Address8 1 harf คือ c1 83
- ที่ตำแหน่ง Address12 1 harf คือ 00 31
3. *Bit* คือ ตำแหน่งใน Address เช่น
- ที่ตำแหน่ง Address1 1 bit คือ 93 
- ที่ตำแหน่ง Address2 1 bit คือ 00

### ตามภาพด้านบนในส่วนของ Address จะมีคำสั่งด้านขวามือ มีความหมาย ดังนี้
1. **addi(add immediate) x1, x0, 32** คือ การนำ 32(12 bit) มาบวกกับ x0 ผลลัพธ์ที่ได้นำไปใส่ที่ x1  *(x0 มีค่าเป็น 0 เสมอ , x ทุกตัวมีขนาด 32 bit(1 word))*    
2. **lui(load upper immediate) x2, 0xc0000000** คือ การนำค่าทางขวามือที่มีค่า 1 word(32 bit) ไปใส่ใน x2(ใส่แค่ 20 bit แรก)
3. **lbu(load byte unsigned) x3, 0(x1)** คือ นำหน่วยความจำที่ Address(x1) 1 bit มาใส่ใน x3
4. **beq(branch on equal) x3, x0, +16** คือ ถ้า x3 มีค่าเท่ากับ x0 ในกระโดดไป +16
5. **sb(store bit) x3, 0(x2)** คือ นำข้อมูลที่ x3 ที่ไม่ใช่ 0 เก็บไว้ที่ Address(x2)
6. **addi(add immediate) x1, x1, 1** คือ 1+x1 เมื่อบวกกันแล้ว เอาไปใส่ที่ x1 
7. **jal(jump and link) x0, -16** คือ กระโดดไป -16
8. **jal(jump and link) x0, 0** คือ เมื่อเงื่อนไขในข้อที่ 4 เป็นจริง ก็จะกระโดดไป 0 หรืออยู่ที่เดิมวนไปมา

### หลักการทำงานของ Software EmulsiV เมื่อกดคำสั่ง run
**คำสั่งด้านซ้ายมือในส่วนของ address จะถูกเรียกไปใช้ในวงจรคำนวณทีละคำสั่ง**

- **คำสั่งที่ 1 :** จะถูกเรียกมา 4 bit(93 00 00 02) มาไว้ที่ Bus แล้วคำสั่งก็จะเลื่อนไปที่ Instruction reg ทางขวามือ เพื่อแปลคำสั่ง ในส่วนของ ALU จะนำ x0 ที่มีค่าเป็น 0 เข้ามา เมื่อแปลเสร็จแล้วก็จะเลื่อนคำสั่งไปที่ ALU ที่ดึงค่า x0 มาแล้ว นำค่าทั้งสองมาบวกกัน และนำผลลัพธ์ที่ได้มาใส่ไว้ที่ x1

- **คำสั่งที่ 2 :** จะถูกเรียกมา 4 bit(37 01 00 c0) มาไว้ที่ Bus แล้วคำสั่งก็จะเลื่อนไปที่ Instruction reg ทางขวามือ เพื่อแปลคำสั่ง เมื่อแปลคำสั่งเสร็จก็จะถูกเลื่อนไปที่ ALU แล้วนำไปใส่ x2

- **คำสั่งที่ 3 :** จะถูกเรียกมา 4 bit(83 c1 00 00) มาไว้ที่ Bus แล้วคำสั่งก็จะเลื่อนไปที่ Instruction reg ทางขวามือ เพื่อแปลคำสั่ง จากคำสั่งคือการ load bit คือในส่วนของ ALU ก็จะโหลดค่าของ x1 มาบวกกับค่าจากการแปลคำสั่ง บวกกันได้เท่าไหร่ให้วิ่งไปที่หน่วยความจำนั้นที่ address มา 1 bit ไว้ที่ Bus แล้วนำค่านั้นไปใส่ไว้ที่ x3

- **คำสั่งที่ 4 :** จะถูกเรียกมา 4 bit(63 88 01 00) มาไว้ที่ Bus แล้วคำสั่งก็จะเลื่อนไปที่ Instruction reg ทางขวามือ เพื่อแปลคำสั่ง จากคำสั่งนั้นคือการให้ตรวจสอบว่าเท่ากันกับ x0 หรือไม่ เทียบที่ Comparator ผลปรากฏว่ายังไม่เท่ากันกับ x0 จึงไปที่คำสั่งถัดไป

- **คำสั่งที่ 5 :** จะถูกเรียกมา 4 bit(23 00 31 00) มาไว้ที่ Bus แล้วคำสั่งก็จะเลื่อนไปที่ Instruction reg ทางขวามือ เพื่อแปลคำสั่ง ในส่วนของ ALU จำนำค่า x2 มาบวกกับค่าจากการแปล ได้เท่าไหร่ก็จะนำไปไว้ที่ Bus เพื่อเตรียมเรียกหน่วยความจำ แล้วนำ x3 เข้ามา คำสั่งก็จะ output ไปที่ Text I/O ก็จะปรากฏข้อความตาม ascii table ออกมา แล้วทำการวนลูปไปเรื่อยๆ 

- **จากคำสั่ง jal(jump and link) x0, 0 :**  คือ เมื่อเทียบค่าแล้วเท่ากันกับ x0 หรือ 0 ในคำสั่งที่ 4 ให้กระโดดไป 0 หรืออยู่ที่เดิมวนไปมา นั่นแสดงว่าโปรแกรมหยุดทำงานแล้ว


*สามารถทำความเข้าใจเพิ่มเติมจากคลิปที่แนบมานี้* [หลักการทำงาน Software EmulsiV](https://drive.google.com/file/d/1QVaVfiDmbTY_JCBmjMaFVl28cYtIK9gp/view?usp=drivesdk)
